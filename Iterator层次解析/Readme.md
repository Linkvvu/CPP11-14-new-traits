### STL基本术语
|术语|意义|
|--|--|
|概念|描述一系列的要求|
|模型|"概念"真正的实现方式，被称为“概念”的模型|
|改进|基于其他概念的概念，即逻辑上的继承关系|

### Iterator的分类与其功能
|迭代器的功能|InPut|OutPut|Forward|Bidirectional|Random-Access|
|--|--|--|--|--|--|
|`解引用*`可读取|√|×|√|√|√|
|`*`可写入(即解引用返回左值)|×|√|√|√|√|
|固定和可重复排序|×|×|√|√|√|
|`++i,i++`|√|√|√|√|√|
|`--i,i--`|×|×|×|√|√|
|`i[n]`|×|×|×|×|√|
|`i + n`|×|×|×|×|√|
|`i - n`|×|×|×|×|√|
|`i += n`|×|×|×|×|√|
|`i -= n`|×|×|×|×|√|

通过该表，不难发现各Iterator之间的**逻辑继承(改进)**

STL中，不同算法对迭代器的**最低要求不同**，如
* `for_each()`要求提供区间的迭代器类型最低应为*InPut-Iterator*，STL容器类的迭代器都满足这一要求。
* `sort()`要求提供区间的迭代器类型最低应为*Random-Access-Iterator*，故`vector`可运用此算法，但`list`的迭代器的tag是*Bidirectional-Iterator*，其不支持随机访问，故无法用于此算法

#### STL中的输入迭代器和输出迭代器的最基本"模型":
* 能表示**输入流**的迭代器：`istream_iterator`模板

  该模板是**输入迭代器**“概念”的一个“模型”
  
  其实现了**operator(*)解引用**可读取的功能

  构造`istream_iterator`迭代器,如`std::istream_iterator<int, char> obj(std::cin)`(第一个"模板参数"为将要读取的值类型，第二个"模板参数"的另一个选择为`wchar_t`)

  其将“标准输入流对象”传入Constructor中，此时构造出的对象`obj`就是一个指向表中输入流的迭代器

  **通过调用迭代器对象`obj`的`operator*()`可读取标准输入流中的数据**

  **通过调用迭代器对象`obj`的`operator++()`为读取下一个标准输入流中的数据做准备，即迭代器逻辑上移动++**

* 能表示**输出流**的迭代器：`ostream_iterator`模板
  
  与上文大体相似，但具有**输出迭代器**的特征

  **通过调用迭代器对象`obj`的`operator*()`可向标准输出流中写入数据**

  **通过调用迭代器对象`obj`的`operator++()`为向标准输出流中写入下一个数据做准备，即迭代器逻辑上移动++**


---
### 扩展：
适配器(Adapter):

通过已有的接口，对这些接口进行**再次封装**，从而实现一个Adapter类或函数，使其能**通过底层提供的接口特性**实现一个焕然一新，能参与至STL中的接口和功能

示例：

`reverse_iterator`迭代器就是通过现有迭代器的接口，对其功能进行**再次改造与封装**，一般是通过内部"包含"一个(具备目标接口的)底层对象,调用其接口并改造

但实现`reverse_iterator`的前提是**要具备反向迭代器所需的接口**

`forward_list`就没有反向迭代器，因为`forward_list`的迭代器tag为*Forward-Iterator*，其没有`--i,i--`的接口，因此不能实现Adapter`reverse_iterator`

故，同理`vector`具备`reverse_iterator`




